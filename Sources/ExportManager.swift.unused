import Foundation
import AppKit

class ExportManager {
    
    // MARK: - Excel Export
    
    func exportExcel(cachedResults: [[String: Any]], sourceFolder: URL, to saveURL: URL, completion: @escaping (Result<Void, Error>) -> Void) {
        
        // Check if we have complete cached results (with chromosome data)
        if let firstResult = cachedResults.first, firstResult["copy_numbers"] != nil {
            exportExcelFromCachedResults(cachedResults: cachedResults, to: saveURL, completion: completion)
        } else {
            // Fallback to full analysis if cached data is incomplete
            exportExcelWithFullAnalysis(sourceFolder: sourceFolder, to: saveURL, completion: completion)
        }
    }
    
    private func exportExcelFromCachedResults(cachedResults: [[String: Any]], to saveURL: URL, completion: @escaping (Result<Void, Error>) -> Void) {
        guard let pythonPath = findPython(),
              let ddquintPath = findDDQuint() else {
            completion(.failure(ExportError.pythonNotFound))
            return
        }
        
        DispatchQueue.global().async {
            do {
                let jsonData = try JSONSerialization.data(withJSONObject: cachedResults, options: [])
                guard let jsonString = String(data: jsonData, encoding: .utf8) else {
                    completion(.failure(ExportError.serializationFailed))
                    return
                }
                
                self.executeExcelExportWithJSON(jsonString: jsonString, saveURL: saveURL, ddquintPath: ddquintPath, pythonPath: pythonPath, completion: completion)
                
            } catch {
                completion(.failure(error))
            }
        }
    }
    
    private func executeExcelExportWithJSON(jsonString: String, saveURL: URL, ddquintPath: String, pythonPath: String, completion: @escaping (Result<Void, Error>) -> Void) {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: pythonPath)
        
        process.environment = (process.environment ?? ProcessInfo.processInfo.environment).merging([
            "MPLBACKEND": "Agg",
            "PYTHONDONTWRITEBYTECODE": "1"
        ]) { _, new in new }
        
        let escapedSavePath = saveURL.path.replacingOccurrences(of: "'", with: "\\'")
        let escapedDDQuintPath = ddquintPath.replacingOccurrences(of: "'", with: "\\'")
        let escapedJsonString = jsonString.replacingOccurrences(of: "'", with: "\\'")
        
        process.arguments = [
            "-c",
            """
            import sys
            import json
            import traceback
            
            try:
                sys.path.insert(0, '\(escapedDDQuintPath)')
                
                # Initialize config
                from ddquint.config import Config
                from ddquint.utils.parameter_editor import load_parameters_if_exist
                
                config = Config.get_instance()
                load_parameters_if_exist(Config)
                config.finalize_colors()
                
                # Import create_list_report
                from ddquint.core import create_list_report
                
                # Parse the cached results
                results = json.loads('\(escapedJsonString)')
                
                # Export to Excel using cached results
                create_list_report(results, '\(escapedSavePath)')
                print('EXCEL_EXPORT_SUCCESS_CACHED')
                
            except Exception as e:
                print(f'EXPORT_ERROR: {e}')
                traceback.print_exc()
                sys.exit(1)
            """
        ]
        
        let outputPipe = Pipe()
        process.standardOutput = outputPipe
        
        do {
            try process.run()
            process.waitUntilExit()
            
            let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: outputData, encoding: .utf8) ?? ""
            
            DispatchQueue.main.async {
                if output.contains("EXCEL_EXPORT_SUCCESS_CACHED") {
                    completion(.success(()))
                    NSWorkspace.shared.activateFileViewerSelecting([saveURL])
                } else {
                    completion(.failure(ExportError.exportFailed("Excel export failed")))
                }
            }
        } catch {
            DispatchQueue.main.async {
                completion(.failure(error))
            }
        }
    }
    
    private func exportExcelWithFullAnalysis(sourceFolder: URL, to saveURL: URL, completion: @escaping (Result<Void, Error>) -> Void) {
        guard let pythonPath = findPython(),
              let ddquintPath = findDDQuint() else {
            completion(.failure(ExportError.pythonNotFound))
            return
        }
        
        DispatchQueue.global().async {
            let process = Process()
            process.executableURL = URL(fileURLWithPath: pythonPath)
            
            process.environment = (process.environment ?? ProcessInfo.processInfo.environment).merging([
                "MPLBACKEND": "Agg",
                "PYTHONDONTWRITEBYTECODE": "1"
            ]) { _, new in new }
            
            let escapedSourcePath = sourceFolder.path.replacingOccurrences(of: "'", with: "\\'")
            let escapedSavePath = saveURL.path.replacingOccurrences(of: "'", with: "\\'")
            let escapedDDQuintPath = ddquintPath.replacingOccurrences(of: "'", with: "\\'")
            
            process.arguments = [
                "-c",
                """
                import sys
                import traceback
                
                try:
                    sys.path.insert(0, '\(escapedDDQuintPath)')
                    
                    # Initialize config
                    from ddquint.config import Config
                    from ddquint.utils.parameter_editor import load_parameters_if_exist
                    
                    config = Config.get_instance()
                    load_parameters_if_exist(Config)
                    config.finalize_colors()
                    
                    # Import modules
                    from ddquint.core import process_directory, create_list_report
                    from ddquint.utils import get_sample_names
                    
                    # Get sample names
                    sample_names = get_sample_names('\(escapedSourcePath)')
                    
                    # Run analysis
                    results = process_directory('\(escapedSourcePath)', None, sample_names, verbose=False)
                    
                    # Add sample names to results
                    for result in results:
                        well_id = result.get('well')
                        if well_id and well_id in sample_names:
                            result['sample_name'] = sample_names[well_id]
                    
                    # Export to Excel
                    create_list_report(results, '\(escapedSavePath)')
                    print('EXCEL_EXPORT_SUCCESS')
                    
                except Exception as e:
                    print(f'EXPORT_ERROR: {e}')
                    traceback.print_exc()
                    sys.exit(1)
                """
            ]
            
            let outputPipe = Pipe()
            process.standardOutput = outputPipe
            
            do {
                try process.run()
                process.waitUntilExit()
                
                let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()
                let output = String(data: outputData, encoding: .utf8) ?? ""
                
                DispatchQueue.main.async {
                    if output.contains("EXCEL_EXPORT_SUCCESS") {
                        completion(.success(()))
                        NSWorkspace.shared.activateFileViewerSelecting([saveURL])
                    } else {
                        completion(.failure(ExportError.exportFailed("Excel export failed")))
                    }
                }
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }
    
    // MARK: - Plot Export
    
    func exportPlots(sourceFolder: URL, to exportURL: URL, completion: @escaping (Result<Void, Error>) -> Void) {
        
        DispatchQueue.global().async {
            do {
                // Simply copy existing plots from Graphs directory - no Python needed
                let graphsDir = sourceFolder.appendingPathComponent("Graphs")
                
                guard FileManager.default.fileExists(atPath: graphsDir.path) else {
                    completion(.failure(ExportError.noGraphsDirectory))
                    return
                }
                
                let plotFiles = try FileManager.default.contentsOfDirectory(at: graphsDir, includingPropertiesForKeys: nil)
                    .filter { $0.pathExtension.lowercased() == "png" }
                
                guard !plotFiles.isEmpty else {
                    completion(.failure(ExportError.noPlotsFound))
                    return
                }
                
                var successCount = 0
                
                for plotFile in plotFiles {
                    let wellId = plotFile.deletingPathExtension().lastPathComponent
                    let exportPath = exportURL.appendingPathComponent("\(wellId)_plot.png")
                    
                    do {
                        try FileManager.default.copyItem(at: plotFile, to: exportPath)
                        successCount += 1
                    } catch {
                        print("Error copying \(plotFile.lastPathComponent): \(error)")
                        // Continue with other files
                    }
                }
                
                DispatchQueue.main.async {
                    if successCount > 0 {
                        completion(.success(()))
                        NSWorkspace.shared.activateFileViewerSelecting([exportURL])
                    } else {
                        completion(.failure(ExportError.exportFailed("No plots could be copied")))
                    }
                }
                
            } catch {
                DispatchQueue.main.async {
                    completion(.failure(error))
                }
            }
        }
    }
    
    // MARK: - Utilities
    
    private func findPython() -> String? {
        let paths = [
            "/usr/bin/python3",
            "/usr/local/bin/python3",
            "/opt/homebrew/bin/python3",
            "/opt/local/bin/python3"
        ]
        
        return paths.first { FileManager.default.fileExists(atPath: $0) }
    }
    
    private func findDDQuint() -> String? {
        // Look for ddQuint in the same directory as the app
        if let executablePath = Bundle.main.executablePath {
            let appDir = URL(fileURLWithPath: executablePath).deletingLastPathComponent().deletingLastPathComponent()
            let ddquintPath = appDir.appendingPathComponent("ddquint").path
            
            if FileManager.default.fileExists(atPath: ddquintPath) {
                return appDir.path
            }
        }
        
        // Fallback to current working directory
        let currentDir = FileManager.default.currentDirectoryPath
        let ddquintPath = URL(fileURLWithPath: currentDir).appendingPathComponent("ddquint").path
        
        if FileManager.default.fileExists(atPath: ddquintPath) {
            return currentDir
        }
        
        return nil
    }
}

// MARK: - Supporting Types

enum ExportError: Error {
    case pythonNotFound
    case serializationFailed
    case exportFailed(String)
    case noGraphsDirectory
    case noPlotsFound
}